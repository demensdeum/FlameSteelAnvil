 <head>
 </head>
 <body>
    <script>
        initializeWithDatabase = (database, verbose) => {
            const createRepository = (storeName) => {
                const getStore = (mode) => database.transaction(storeName, mode).objectStore(storeName)

                return {
                    getAll: () => new Promise((resolve, reject) => {
                        const results = []
                        const request = getStore("readonly").openCursor()
                        request.onsuccess = () => {
                            const cursor = request.result
                            if (cursor) {
                                results.push(cursor.value)
                                cursor.continue()
                            } else {
                                resolve(results)
                            }
                        }
                        request.onerror = () => reject(request.error)
                    }),
                    create: (data) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").add(data)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    read: (id) => new Promise((resolve, reject) => {
                        const request = getStore("readonly").get(id)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    update: (data) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").put(data)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    delete: (id) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").delete(id)
                        request.onsuccess = () => resolve()
                        request.onerror = () => reject(request.error)
                    })
                }
            }

            let projectsRepository = createRepository("projects")
            let scenesRepository = createRepository("scenes")
            let backgroundsRepository = createRepository("backgrounds")
            let projectFirstSceneRepository = createRepository("projectFirstScene")
            let sceneBackgroundImageRepository = createRepository("sceneBackgroundImage")
            let primaryChoiceRepository = createRepository("primaryChoiceLink")
            let blobRepository = createRepository("blob")

            const debugPrint = (info) => {
                if (verbose) {
                    console.log(info)
                }
            }
            debugPrint(database)
            const none = "<NONE>"
            const doID = () => {
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
                    let result = ''
                    for (let i = 0; i < 16; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length))
                    }
                return result
            }
            let state = {
                "database" : database,
                "project" : none,
                "image" : none,
                "choice" : none,
                "scene" : none
            }
            const listOfProjects = (completion) => {
                let database = state.database
                let transaction = database.transaction("projects", "readwrite")
                let projectsObjectStore = transaction.objectStore("projects")
                let request = projectsObjectStore.openCursor()
                var projects = []
                request.onsuccess = function() {
                    let cursor = request.result
                    if (cursor) {
                        let key = cursor.key
                        let value = cursor.value
                        debugPrint([key, value])
                        projects.push(value)
                        cursor.continue()
                    } else {
                        debugPrint("No more projects")
                        completion(projects)
                    }
                }                
            }
            const createFirstSceneForSelectedProject = async () => {
                return new Promise((resolve) => {
                    let transaction = database.transaction("scenes", "readwrite")
                    let scenes = transaction.objectStore("scenes")

                    const id = doID()

                    let scene = {
                        id: id,
                    }

                    let request = scenes.add(scene)
                    request.onsuccess = () => {
                        state.scene = id
                        debugPrint(`Scene success added: ${id}`)

                        let transaction = database.transaction("projectFirstScene", "readwrite")
                        let projectFirstSceneStore = transaction.objectStore("projectFirstScene")
                        let projectFirstScene = {
                            id: state.project,
                            destination: id
                        }
                        let request = projectFirstSceneStore.add(projectFirstScene)

                        request.onsuccess = () => {
                            debugPrint(`createFirstSceneForSelectedProject -> ${projectFirstScene.destination} -> request.onsuccess`)
                            resolve()
                        }
                    }

                    request.onerror = () => {
                        debugPrint(`Scene add scene error: ${request.error}`)
                    }
                })
            }
            const createNewProject = async () => {
                return new Promise((resolve) => {
                    let transaction = database.transaction("projects", "readwrite")
                    let projects = transaction.objectStore("projects")

                    let project = {
                        id: doID(),
                    }

                    let request = projects.add(project)
                    request.onsuccess = async () => {
                        debugPrint(`Project added to the store: ${request.result}`)
                        state.project = project.id
                        await createFirstSceneForSelectedProject()
                        renderState()
                        resolve()
                    }
                    request.onerror = () => {
                        debugPrint(`"Project add to the store error: ${request.error}`)
                    }
                })
            }
            const selectProject = (id) => {
                state.project = id
                debugPrint("selectProject: " + id)
                
                if (id === none) {
                    state.scene = none
                    renderState()
                    return
                }

                let transaction = database.transaction("projectFirstScene", "readonly")
                let store = transaction.objectStore("projectFirstScene")
                let request = store.get(id)

                request.onsuccess = () => {
                    if (request.result) {
                        state.scene = request.result.destination
                        debugPrint("found first scene: " + state.scene)
                    } else {
                        state.scene = none
                        debugPrint("no first scene found for project")
                    }
                    renderState()
                }
                
                request.onerror = () => {
                    state.scene = none
                    renderState()
                }
            }
            const deleteSelectedProject = () => {
                if (state.project == none) {
                    return
                }
                if (confirm(`Delete project ${state.project}?`)) {
                    let transaction = database.transaction("projects", "readwrite")
                    let projects = transaction.objectStore("projects")
                    let request = projects.delete(state.project)
                    request.onsuccess = () => {
                        debugPrint("Project success delete")
                    }
                    request.onerror = () => {
                        debugPrint(`Project remove from the store error: ${request.error}`)
                    }
                }
            }
            const uploadFile = (file) => {
                if (!file) return
                let transaction = database.transaction("blob", "readwrite")
                let blob = transaction.objectStore("blob")

                let blobID = doID()
                const item = {
                    id: blobID,
                    data: file
                }

                debugPrint(blobID)

                let request = blob.add(item)
                request.onsuccess = () => {
                    debugPrint(`blob uploaded: ${blobID}`)

                    let transaction = database.transaction("backgrounds", "readwrite")
                    let backgrounds = transaction.objectStore("backgrounds")

                    const item = {
                        id: blobID
                    }

                    let request = backgrounds.add(item)
                    request.onsuccess = () => {
                        renderState()
                    }
                    request.onerror = () => {
                        debugPrint(request.error)
                    }
                }
            }
            const selectImage = (id) => {
            }
            const removeSelectedImage = () => {
            }
            const addSelectedImageToScene = (position) => {
            }
            const removeSelectedImageFromScene = () => {
            }
            const addChoice = () => {
            }
            const selectChoice = (id) => {
            }
            const deleteSelectedChoice = () => {
            }
            const switchToNextScene = () => {
            }
            const switchToPreviousScene = () => {
            }
            const renderProjectsSection = () => {
                let projectsSection = document.getElementById('projectsSection')
                projectsSection.innerHTML = ''

                listOfProjects((projects) => {
                    debugPrint(projects)
                    let select = document.createElement('select')
                    select.onchange = () => {
                        selectProject(select.value)
                    }
                    let option = document.createElement('option')
                    option.textContent = none
                    select.appendChild(option)

                    if (projects.length > 0) {
                        projects.forEach(e => {
                            let option = document.createElement('option')
                            option.textContent = e.id
                            select.appendChild(option)
                            if (state.project == e.id) {
                                select.value = e.id
                            }
                        })
                        projectsSection.appendChild(select)
                    } 
                    else {
                        let p = document.createElement('p')
                        p.textContent = "No projects"
                        projectsSection.appendChild(p)
                    }

                    let br = document.createElement("br")
                    projectsSection.appendChild(br)

                    let newProjectButton = document.createElement("button")
                    newProjectButton.textContent = "New Project"
                    newProjectButton.onclick = createNewProject
                    projectsSection.appendChild(newProjectButton)

                    let deleteProjectButton = document.createElement("button")
                    deleteProjectButton.textContent = "Delete Project"
                    deleteProjectButton.onclick = deleteSelectedProject
                    projectsSection.appendChild(deleteProjectButton)
                })
            }
            const uploadBackgroundImage = () => {
                debugPrint("uploadBackgroundImage")
            }
            const listOfBackgrounds = (completion) => {
                let database = state.database
                let transaction = database.transaction("backgrounds", "readwrite")
                let backgroundsObjectStore = transaction.objectStore("backgrounds")
                let request = backgroundsObjectStore.openCursor()
                var backgrounds = []
                request.onsuccess = function() {
                    let cursor = request.result
                    if (cursor) {
                        let key = cursor.key
                        let value = cursor.value
                        debugPrint([key, value])
                        backgrounds.push(value)
                        cursor.continue()
                    } else {
                        debugPrint("No more backgrounds")
                        completion(backgrounds)
                    }
                }
            }
            const selectBackground = (background) => {
                let transaction = database.transaction("sceneBackgroundImage", "readwrite")
                let store = transaction.objectStore("sceneBackgroundImage")

                const entry = {
                    id: state.scene,
                    destination: background
                }

                let request = store.put(entry)
                
                request.onsuccess = () => {
                    debugPrint(`Background ${background} saved for scene ${state.scene}`)
                    renderState();
                }

                request.onerror = (e) => {
                    debugPrint(`Error saving background: ${e.target.error}`)
                }
            }
            const renderSceneBackgroundSection = async () => {
                if (state.project == none) {
                    return
                }
                return new Promise((resolve) => {
                    let liveEditorSection = document.getElementById('liveEditorSection')
                    liveEditorSection.innerHTML = ''

                    let database = state.database
                    let transaction = database.transaction("sceneBackgroundImage", "readwrite")
                    let sceneBackgroundImageObjectStore = transaction.objectStore("sceneBackgroundImage")
                    debugPrint(`state.scene: ${state.scene}`)
                    let request = sceneBackgroundImageObjectStore.get(state.scene)

                    request.onsuccess = () => {
                        let cursor = request.result
                        if (cursor) {
                            debugPrint(`Scene background: ${cursor.destination}`)
                            let liveEditorSection = document.getElementById('liveEditorSection')
                            let p = document.createElement('p')
                            p.textContent = `Background: ${cursor.destination}`
                            liveEditorSection.appendChild(p)
                        }
                        else {
                            let p = document.createElement('p')
                            p.textContent = none
                            liveEditorSection.appendChild(p)
                        }

                        let br = document.createElement("br")
                        liveEditorSection.appendChild(br)

                        listOfBackgrounds((backgrounds) => {
                            debugPrint(backgrounds)
                            let select = document.createElement('select')
                            select.onchange = () => {
                                selectBackground(select.value)
                            }
                            let option = document.createElement('option')
                            option.textContent = none
                            select.appendChild(option)

                            if (backgrounds.length > 0) {
                                backgrounds.forEach(e => {
                                    let option = document.createElement('option')
                                    option.textContent = e.id
                                    select.appendChild(option)
                                })
                                liveEditorSection.appendChild(select)
                            }
                            else {
                                let p = document.createElement('p')
                                p.textContent = "No Backgrounds"
                                liveEditorSection.appendChild(p)
                            }

                            let uploadBackgroundImageInput = document.createElement('input')
                            uploadBackgroundImageInput.type = 'file';
                            uploadBackgroundImageInput.accept = 'image/*';
                            uploadBackgroundImageInput.textContent = "Upload Background Image"
                            uploadBackgroundImageInput.onchange = (e) => {
                                let file = e.target.files[0]
                                uploadFile(file)
                            }
                            liveEditorSection.appendChild(uploadBackgroundImageInput)

                            let br = document.createElement("br")
                            liveEditorSection.appendChild(br)

                            resolve()
                        })
                    }
                })
            }
            const renderSceneTextSection  = async () => {
                return new Promise((resolve) => {
                    let liveEditorSection = document.getElementById('liveEditorSection')

                    let p = document.createElement('p')
                    p.textContent = none
                    liveEditorSection.appendChild(p)

                    resolve()
                })
            }
            const addNextScene = async () => {
                return new Promise((resolve) => {
                    let id = doID()
                    let transaction = database.transaction("primaryChoiceLink", "readwrite")
                    let primaryChoiceLinkObjectStore = transaction.objectStore("primaryChoiceLink")
                    let request = primaryChoiceLinkObjectStore.add({
                        id: state.scene,
                        destination: id
                    })
                    request.onsuccess = () => {
                        renderState()
                        resolve()
                    }
                    request.onerror = () => {
                        debugPrint(request.error)
                    }
                })
            }
            const renderScenePrimaryChoiceSection = async () => {
                return new Promise((resolve) => {
                    let transaction = database.transaction("primaryChoiceLink", "readonly")
                    let request = transaction.objectStore("primaryChoiceLink").get(state.scene)

                    let liveEditorSection = document.getElementById('liveEditorSection')

                    request.onsuccess = () => {
                        if (request.result) {
                            let p = document.createElement('p');
                            p.textContent = `Next Scene: ${request.result.destination}`
                            liveEditorSection.appendChild(p)
                            
                            let btnGo = document.createElement('button')
                            btnGo.textContent = "Edit Next Scene"
                            btnGo.onclick = () => {
                                state.scene = request.result.destination
                                renderState()
                            }
                            liveEditorSection.appendChild(btnGo)
                        } else {
                            let btnAdd = document.createElement('button')
                            btnAdd.textContent = "Add Next Scene"
                            btnAdd.style.background = "#007bff"
                            btnAdd.style.color = "white"
                            btnAdd.onclick = addNextScene
                            liveEditorSection.appendChild(btnAdd)
                        }
                        resolve()
                    }
                })
            }
            const renderSceneSecondaryChoiceSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneSecondaryChoiceSection")
                    resolve()
                })
            }
            const renderSceneTetriaryChoiceSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneTetriaryChoiceSection")
                    resolve()
                })
            }
            const renderSceneMusicSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneMusicSection")
                    resolve()
                })
            }
            const renderSceneSoundSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneSoundSection")
                    resolve()
                })
            }
            async function renderLiveEditor() {
                debugPrint("renderLiveEditor")
                let liveEditorSection = document.getElementById('liveEditorSection')
                liveEditorSection.innerHTML = ''

                await renderSceneBackgroundSection()
                await renderSceneTextSection()
                await renderScenePrimaryChoiceSection()
                await renderSceneSecondaryChoiceSection()
                await renderSceneTetriaryChoiceSection()
                await renderSceneMusicSection()
                await renderSceneSoundSection()
            }
            const renderState = (state) => {
                debugPrint("renderState")
                renderProjectsSection()
                renderLiveEditor()
            }
            renderState(state)
        }
        main = (options) => {
            let databaseOpenRequest = indexedDB.open("database", 1)
            databaseOpenRequest.onupgradeneeded = () => {
                let database = databaseOpenRequest.result
                createOneToOneObjectStore = (database, objectStoreName) => {
                    const store = database.createObjectStore(objectStoreName, { keyPath: "id" })
                    store.createIndex("destination_index", "destination", { unique: false })
                }
                database.createObjectStore("projects", {keyPath: "id"})
                createOneToOneObjectStore(database, "scenes")
                createOneToOneObjectStore(database, "backgrounds")
                createOneToOneObjectStore(database, "projectFirstScene")
                createOneToOneObjectStore(database, "sceneBackgroundImage")
                createOneToOneObjectStore(database, "scenePrimaryImage")
                createOneToOneObjectStore(database, "sceneSecondaryImage")
                createOneToOneObjectStore(database, "sceneTeriaryImage")
                createOneToOneObjectStore(database, "sceneMusic")
                createOneToOneObjectStore(database, "sceneSound")
                createOneToOneObjectStore(database, "primaryChoiceLink")
                createOneToOneObjectStore(database, "secondaryChoiceLink")
                createOneToOneObjectStore(database, "tetriaryChoiceLink")
                database.createObjectStore("blob", {keyPath: "id"})
                createOneToOneObjectStore(database, "translatedStrings")
            }
            databaseOpenRequest.onsuccess = () => {
                let database = databaseOpenRequest.result
                initializeWithDatabase(database, options.verbose)
            }
        }
        main({"verbose" : true})
    </script>
    <div id="projectsSection">Loading list of projects...</div>
    <div id="liveEditorSection">Loading list of projects...</div>
 </body>
