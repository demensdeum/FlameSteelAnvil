 <head>
 </head>
 <body>
    <script>
        initializeWithDatabase = (database, verbose) => {
            const createRepository = (storeName) => {
                const getStore = (mode) => database.transaction(storeName, mode).objectStore(storeName)

                return {
                    getAll: () => new Promise((resolve, reject) => {
                        const results = []
                        const request = getStore("readonly").openCursor()
                        request.onsuccess = () => {
                            const cursor = request.result
                            if (cursor) {
                                results.push(cursor.value)
                                cursor.continue()
                            } else {
                                resolve(results)
                            }
                        }
                        request.onerror = () => reject(request.error)
                    }),
                    create: (data) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").add(data)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    read: (id) => new Promise((resolve, reject) => {
                        const request = getStore("readonly").get(id)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    update: (data) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").put(data)
                        request.onsuccess = () => resolve(request.result)
                        request.onerror = () => reject(request.error)
                    }),
                    delete: (id) => new Promise((resolve, reject) => {
                        const request = getStore("readwrite").delete(id)
                        request.onsuccess = () => resolve()
                        request.onerror = () => reject(request.error)
                    })
                }
            }

            const storeNames = [
                "projects", "scenes", "backgrounds", "projectFirstScene",
                "sceneBackgroundImage", "scenePrimaryImage", "sceneSecondaryImage",
                "sceneTeriaryImage", "sceneMusic", "sceneSound",
                "primaryChoiceLink", "secondaryChoiceLink", "tetriaryChoiceLink",
                "translatedStrings", "blob"
            ]

            const repositories = Object.fromEntries(
                storeNames.map(name => [name, createRepository(name)])
            )

            const debugPrint = (info) => {
                if (verbose) {
                    console.log(info)
                }
            }
            debugPrint(database)
            const none = "<NONE>"
            const doID = () => {
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
                    let result = ''
                    for (let i = 0; i < 16; i++) {
                        result += chars.charAt(Math.floor(Math.random() * chars.length))
                    }
                return result
            }
            let state = {
                database : database,
                project : none,
                image : none,
                choice : none,
                scene : none,
                language: 'en'
            }
            const importDatabaseFromJson = async (jsonFile) => {
                const reader = new FileReader()

                reader.onload = async (e) => {
                    const importData = JSON.parse(e.target.result)

                    for (const storeName of Object.keys(importData)) {
                        const records = importData[storeName]

                        for (const record of records) {
                            if (record.data && typeof record.data === 'string' && record.data.startsWith('data:')) {
                                record.data = base64ToBlob(record.data)
                            }

                            await repositories[storeName].update(record)
                        }
                    }
                    debugPrint("Database imported successfully.")
                }

                reader.readAsText(jsonFile)
            }

            const base64ToBlob = (base64String) => {
                // Split the prefix (e.g. "data:image/png;base64,") from the actual data
                const parts = base64String.split(',')
                const contentType = parts[0].indexOf(':') !== -1 ? parts[0].split(':')[1].split(';')[0] : 'application/octet-stream'

                // Get the raw base64 string (the second part)
                const rawBase64 = parts.length > 1 ? parts[1] : parts[0]

                // Remove any whitespace or newlines that might cause "invalid character" errors
                const cleanedBase64 = rawBase64.replace(/\s/g, '')

                try {
                    const byteCharacters = atob(cleanedBase64)
                    const byteNumbers = new Array(byteCharacters.length)
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i)
                    }
                    const byteArray = new Uint8Array(byteNumbers)
                    return new Blob([byteArray], { type: contentType })
                } catch (e) {
                    console.error("Failed to decode base64 string:", e)
                    return null
                }
            }
            const exportDatabaseToJson = async () => {
                const exportData = {}

                for (const storeName of storeNames) {
                    const records = await repositories[storeName].getAll()

                    exportData[storeName] = await Promise.all(records.map(async (record) => {
                        if (record.data && record.data instanceof Blob) {
                            return {
                                ...record,
                                data: await blobToBase64(record.data)
                            }
                        }
                        return record
                    }))
                }

                const jsonString = JSON.stringify(exportData, null, 2)

                const blob = new Blob([jsonString], { type: "application/json" })
                const url = URL.createObjectURL(blob)
                const link = document.createElement("a")
                link.href = url
                link.download = `vn_export_${new Date().getTime()}.json`
                document.body.appendChild(link)
                link.click()
                document.body.removeChild(link)
                URL.revokeObjectURL(url)
                debugPrint("Database exported successfully.")
            }

            const blobToBase64 = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader()
                    reader.onloadend = () => resolve(reader.result)
                    reader.onerror = reject
                    reader.readAsDataURL(blob)
                })
            }
            const createFirstSceneForSelectedProject = async () => {
                return new Promise((resolve) => {
                    repoitories.projectFirstScene.create({id: doID() })
                    renderState()
                    resolve()
                })
            }
            const createNewProject = async () => {
                return new Promise((resolve) => {
                    const projectID = doID()
                    const firstSceneID = doID()
                    repositories.projects.create({id: projectID })
                    repositories.scenes.create({id: firstSceneID })
                    repositories.projectFirstScene.create({id: projectID, destination: firstSceneID })
                    renderState()
                    resolve()
                })
            }
            const selectProject = async (id) => {
                state.project = id
                debugPrint("selectProject: " + id)
                
                if (id === none) {
                    state.scene = none
                    renderState()
                    return
                }
                state.scene = (await repositories.projectFirstScene.read(state.project))?.destination
                renderState()
            }
            const deleteSelectedProject = () => {
                if (state.project == none) {
                    return
                }
                repositories.projects.delete(state.project)
                renderState()
                resolve()
            }
            const uploadFile = async (file) => {
                if (!file) return
                const blobID = doID()
                await repositories.blob.create({
                    id: blobID,
                    data: file
                })

                await repositories.backgrounds.create({
                        id: blobID
                })
                renderState()
            }
            const renderProjectsSection = async () => {
                let projectsSection = document.getElementById('projectsSection')
                projectsSection.innerHTML = ''

                const projects = await repositories.projects.getAll()
                debugPrint(projects)
                let select = document.createElement('select')
                select.onchange = () => {
                    selectProject(select.value)
                }
                let option = document.createElement('option')
                option.textContent = none
                select.appendChild(option)

                if (projects.length > 0) {
                    projects.forEach(e => {
                        let option = document.createElement('option')
                        option.textContent = e.id
                        select.appendChild(option)
                        if (state.project == e.id) {
                            select.value = e.id
                        }
                    })
                    projectsSection.appendChild(select)
                }
                else {
                    let p = document.createElement('p')
                    p.textContent = "No projects"
                    projectsSection.appendChild(p)
                }

                let br = document.createElement("br")
                projectsSection.appendChild(br)

                let newProjectButton = document.createElement("button")
                newProjectButton.textContent = "New Project"
                newProjectButton.onclick = createNewProject
                projectsSection.appendChild(newProjectButton)

                let deleteProjectButton = document.createElement("button")
                deleteProjectButton.textContent = "Delete Project"
                deleteProjectButton.onclick = deleteSelectedProject
                projectsSection.appendChild(deleteProjectButton)

                let exportButton = document.createElement("button")
                exportButton.textContent = "Export Data (JSON)"
                exportButton.style.background = "#6c757d"
                exportButton.style.color = "white"
                exportButton.onclick = exportDatabaseToJson
                projectsSection.appendChild(exportButton)

                let btnImport = document.createElement("button")
                btnImport.textContent = "Import Data (JSON)"
                btnImport.style.background = "#007bff"
                btnImport.style.color = "white"

                let fileInput = document.createElement("input")
                fileInput.type = "file"
                fileInput.accept = ".json"
                fileInput.style.display = "none"
                fileInput.onchange = (e) => {
                    if (e.target.files[0]) importDatabaseFromJson(e.target.files[0])
                }

                btnImport.onclick = () => fileInput.click()
                projectsSection.appendChild(btnImport)
                projectsSection.appendChild(fileInput)
            }
            const uploadBackgroundImage = () => {
                debugPrint("uploadBackgroundImage")
            }

            const selectBackground = async (background) => {
                await repositories.sceneBackgroundImage.update({ id: state.scene, destination: background})
                renderState()
            }
            const renderSceneBackgroundSection = async () => {
                if (state.project == none) {
                    return
                }
                return new Promise(async (resolve)  => {
                    let liveEditorSection = document.getElementById('liveEditorSection')
                    liveEditorSection.innerHTML = ''

                    let sceneBackgroundImage = (await repositories.sceneBackgroundImage.read(state.scene))?.destination
                    if (sceneBackgroundImage) {
                        let blobData = (await repositories.blob.read(sceneBackgroundImage))?.data
                        debugPrint(`Scene background: ${sceneBackgroundImage}`)
                        let liveEditorSection = document.getElementById('liveEditorSection')
                        let p = document.createElement('p')

                        let img = document.createElement('img')
                        img.src = URL.createObjectURL(blobData)
                        img.style.width = "70%"

                        p.textContent = `Background: ${sceneBackgroundImage}`
                        liveEditorSection.appendChild(img)
                        liveEditorSection.appendChild(p)
                    }
                    else {
                        let p = document.createElement('p')
                        p.textContent = none
                        liveEditorSection.appendChild(p)
                    }

                    let backgrounds = await repositories.backgrounds.getAll()
                    debugPrint(backgrounds)
                    let select = document.createElement('select')
                    select.onchange = () => {
                        selectBackground(select.value)
                    }
                    let option = document.createElement('option')
                    option.textContent = none
                    select.appendChild(option)

                    if (backgrounds.length > 0) {
                        backgrounds.forEach(e => {
                            let option = document.createElement('option')
                            option.textContent = e.id
                            select.appendChild(option)
                        })
                        liveEditorSection.appendChild(select)
                    }
                    else {
                        let p = document.createElement('p')
                        p.textContent = "No Backgrounds"
                        liveEditorSection.appendChild(p)
                    }

                    let uploadBackgroundImageInput = document.createElement('input')
                    uploadBackgroundImageInput.type = 'file';
                    uploadBackgroundImageInput.accept = 'image/*';
                    uploadBackgroundImageInput.textContent = "Upload Background Image"
                    uploadBackgroundImageInput.onchange = (e) => {
                        let file = e.target.files[0]
                        uploadFile(file)
                    }
                    liveEditorSection.appendChild(uploadBackgroundImageInput)

                    let br = document.createElement("br")
                    liveEditorSection.appendChild(br)

                    resolve()
                })
            }
            const sceneTextKey = () => {
                return `${state.language}-${state.scene}`
            }
            const selectLanguage = (language) => {
                state.language = language
                renderState()
            }
            const sceneText = async() => {
                const key = await sceneTextKey()
                const text = (await repositories.translatedStrings.read(key))?.destination
                return text
            }
            const handleSceneTextChange = async (event) => {
                await repositories.translatedStrings.update({id: sceneTextKey(), destination: event.target.value})
            }
            const renderSceneTextSection  = async () => {
                    let liveEditorSection = document.getElementById('liveEditorSection')
                    const languages = ["en", "ru"]

                    let select = document.createElement('select')
                    select.onchange = () => {
                        selectLanguage(select.value)
                    }

                    languages.forEach(e => {
                        let option = document.createElement('option')
                        option.textContent = e
                        select.appendChild(option)

                        if (state.language == e) {
                            select.value = e
                        }
                    })
                    liveEditorSection.appendChild(select)

                    let sceneKeyParagraph = document.createElement('p')
                    sceneKeyParagraph.textContent = sceneTextKey()
                    liveEditorSection.appendChild(sceneKeyParagraph)

                    let sceneTextInput = document.createElement('textarea')
                    sceneTextInput.value = await sceneText()
                    sceneTextInput.rows = 4
                    sceneTextInput.style.width = "100%"
                    sceneTextInput.style.resize = "vertical"
                    sceneTextInput.onchange = handleSceneTextChange
                    liveEditorSection.appendChild(sceneTextInput)

            }
            const addNextScene = async () => {
                const id = doID()
                await repositories.scenes.create({id: id})
                await repositories.primaryChoiceLink.create({
                        id: state.scene,
                        destination: id
                })
                renderState()
            }
            const addSecondaryScene = async () => {
                const id = doID()
                await repositories.scenes.create({id: id})
                await repositories.secondaryChoiceLink.create({
                    id: state.scene,
                    destination: id
                })
                renderState()
            }
            const addTetriaryScene = async () => {
                const id = doID()
                await repositories.scenes.create({id: id})
                await repositories.tetriaryChoiceLink.create({
                    id: state.scene,
                    destination: id
                })
                renderState()
            }
            const renderScenePrimaryChoiceSection = async () => {
                const primaryChoiceLink = (await repositories.primaryChoiceLink.read(state.scene))?.destination
                if (primaryChoiceLink) {
                        let p = document.createElement('p');
                        p.textContent = `Next Scene: ${primaryChoiceLink}`
                        liveEditorSection.appendChild(p)

                        let btnGo = document.createElement('button')
                        btnGo.textContent = "Edit Next Scene"
                        btnGo.onclick = () => {
                            state.scene = primaryChoiceLink
                            renderState()
                        }
                        liveEditorSection.appendChild(btnGo)
                    } else {
                        let btnAdd = document.createElement('button')
                        btnAdd.textContent = "Add Next Scene"
                        btnAdd.style.background = "#007bff"
                        btnAdd.style.color = "white"
                        btnAdd.onclick = addNextScene
                        liveEditorSection.appendChild(btnAdd)
                }
            }
            const renderSceneSecondaryChoiceSection = async () => {
                const secondaryChoiceLink = (await repositories.secondaryChoiceLink.read(state.scene))?.destination
                if (secondaryChoiceLink) {
                    let p = document.createElement('p');
                    p.textContent = `Secondary Choice Link: ${secondaryChoiceLink}`
                    liveEditorSection.appendChild(p)

                    let btnGo = document.createElement('button')
                    btnGo.textContent = "Edit Secondary Choice Scene"
                    btnGo.onclick = () => {
                        state.scene = secondaryChoiceLink
                        renderState()
                    }
                    liveEditorSection.appendChild(btnGo)
                } else {
                    let btnAdd = document.createElement('button')
                    btnAdd.textContent = "Add Secondary Choice Scene"
                    btnAdd.style.background = "#28a745"
                    btnAdd.style.color = "white"
                    btnAdd.onclick = addSecondaryScene
                    liveEditorSection.appendChild(btnAdd)
                }
            }
            const renderSceneTetriaryChoiceSection = async () => {
                const tetriaryChoiceLink = (await repositories.tetriaryChoiceLink.read(state.scene))?.destination
                if (tetriaryChoiceLink) {
                    let p = document.createElement('p');
                    p.textContent = `Tetriary Choice Link: ${tetriaryChoiceLink}`
                    liveEditorSection.appendChild(p)

                    let btnGo = document.createElement('button')
                    btnGo.textContent = "Edit Tetriary Choice Scene"
                    btnGo.onclick = () => {
                        state.scene = tetriaryChoiceLink
                        renderState()
                    }
                    liveEditorSection.appendChild(btnGo)
                } else {
                    let btnAdd = document.createElement('button')
                    btnAdd.textContent = "Add Tetriary Choice Scene"
                    btnAdd.style.background = "#dc3545"
                    btnAdd.style.color = "white"
                    btnAdd.onclick = addTetriaryScene
                    liveEditorSection.appendChild(btnAdd)
                }
            }
            const renderSceneMusicSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneMusicSection")
                    resolve()
                })
            }
            const renderSceneSoundSection = async () => {
                return new Promise((resolve) => {
                    debugPrint("renderSceneSoundSection")
                    resolve()
                })
            }
            async function renderLiveEditor() {
                debugPrint("renderLiveEditor")
                let liveEditorSection = document.getElementById('liveEditorSection')
                liveEditorSection.innerHTML = ''

                await renderSceneBackgroundSection()
                await renderSceneTextSection()
                await renderScenePrimaryChoiceSection()
                await renderSceneSecondaryChoiceSection()
                await renderSceneTetriaryChoiceSection()
                await renderSceneMusicSection()
                await renderSceneSoundSection()
            }
            const renderState = (state) => {
                debugPrint("renderState")
                renderProjectsSection()
                renderLiveEditor()
            }
            renderState(state)
        }
        main = (options) => {
            let databaseOpenRequest = indexedDB.open("database", 1)
            databaseOpenRequest.onupgradeneeded = () => {
                let database = databaseOpenRequest.result
                createOneToOneObjectStore = (database, objectStoreName) => {
                    const store = database.createObjectStore(objectStoreName, { keyPath: "id" })
                    store.createIndex("destination_index", "destination", { unique: false })
                }
                database.createObjectStore("projects", {keyPath: "id"})
                createOneToOneObjectStore(database, "scenes")
                createOneToOneObjectStore(database, "backgrounds")
                createOneToOneObjectStore(database, "projectFirstScene")
                createOneToOneObjectStore(database, "sceneBackgroundImage")
                createOneToOneObjectStore(database, "scenePrimaryImage")
                createOneToOneObjectStore(database, "sceneSecondaryImage")
                createOneToOneObjectStore(database, "sceneTeriaryImage")
                createOneToOneObjectStore(database, "sceneMusic")
                createOneToOneObjectStore(database, "sceneSound")
                createOneToOneObjectStore(database, "primaryChoiceLink")
                createOneToOneObjectStore(database, "secondaryChoiceLink")
                createOneToOneObjectStore(database, "tetriaryChoiceLink")
                database.createObjectStore("blob", {keyPath: "id"})
                createOneToOneObjectStore(database, "translatedStrings")
            }
            databaseOpenRequest.onsuccess = () => {
                let database = databaseOpenRequest.result
                initializeWithDatabase(database, options.verbose)
            }
        }
        main({"verbose" : true})
    </script>
    <div id="projectsSection">Loading list of projects...</div>
    <div id="liveEditorSection">Loading list of projects...</div>
 </body>
